# 07. 행위

## 제어흐름

### 제어흐름

제어흐름은 자바 언어의 근간 중 하나다.

* 인접한 구문은 순서대로 수행된다.
* 조건문을 사용해 특정 상태에서만 코드를 수행하게 할 수 있다.
* 루프를 사용하면 반복적으로 코드를 수행할 수 있다.
* 예외를 사용하면 제어 흐름을 한번에 바꿀 수도 있다.

이러한 매커니즘을 활용해서 프로그램을 하나의 큰 흐름으로 표현할수도, 여러개의 흐름으로 표현할수도 있다.

```
제어흐름은 관련된것들끼리 모아서 코드를 처음 보는 사람도 쉽게 이해할 수 있게 하는것이 좋다.
```

### 주요흐름 

```
프로그램의 주요 흐름을 명확히 표현하고, 흔치 않은 상황이나 에러는 예외와 조건절을 사용해서 표현하자.
```

* 가끔 수행되고 가끔 변하는 부분을 장황하게 늘어놓으면 사람들이 자주 읽고 이해하고 수정해야 하는 부분이 오히려 불명확해진다.
* 예외 조건이 중요하지 않다는게 아니라, 주요 흐름을 명확하게 나타내는것이 더욱 중요하다는 것이다.


## 메시지

### 메시지

자바는 메시지를 이용해서 로직을 표현한다.

* 프로그램을 데이터와 처리방법으로 나누는것이 아니라, "객체"라는 기본 단위로 나누고 이 객체들의 상호작용으로 서술하는 방식이다.
* 객체는 다른 객체와 협력하기위해 메시지를 전송하고, 메시지를 수신한 객체는 메시지를 처리한다.
* 그리고 이 메커니즘은 객체, 메소드, 매개변수로 표현된다.


제어 흐름의 메커니즘으로 메시지방식을 사용하면 프로그램에서는 상태의 변화가 중요해진다. 

> 여기서 상태 변화란 객체의 상태(=객체 내 필드값)를 의미하는듯.

* 객체가 메시지를 받으면 발신자의 상태는 바뀌지 않지만 수신자의 상태는 바뀔 수 있다.
* **로직을 명확하고 직접적으로 표현하고, 세부구현을 적당히 미루도록** 코드를 작성하는게 좋다.

### 선택 메시지

구현 선택을 위해 메시지를 보낼수도 있다. (case문과 같은 목적)

* Example. `display()`는 런타임에 브러시 타입에 따라 구현이 달라진다.

```java
public void displayShape(Shape subject, Brush brush) {
	brush.display(subject);
}
```

* 장점
   * 명시적 조건문의 사용을 크게 줄일 수 있다. 
   * 추후 확장이 쉽다.

* 단점
	* 연산의 세부 구현을 이해하기 위해 여러개의 클래스를 살펴봐야 한다.

### 더블 디스패치

선택 메시지를 사용하면 일차원적 변형을 잘 표현할 수 있다. 

2차원적 변형을 표현하려면 아래와같이 나타낼 수 있다.

* Example. subject도 변형 포인트, brush도 변형 포인트

```java

displayShape(Shape subject, Brush brush) {
	subject.displayWith(brush);
}

Oval.displayWith(Brush brush) {
	brush.displayOval(this);
}

Rectangle.displayWith(Brush brush) {
	brush.displayRectangle(this);
}
```

* 장점
	* 2차원 변형을 표현할 수 있다.
 
* 단점
	* 더블디스패치를 사용하면 유연성을 조금 잃게되며, 코드 중복이 발생한다.
		* 첫번째(shape) 타입 이름이 두번째(brush) 메소드에 들어간다.
		* 위의 경우 새로운 Shape를 추가하기 위해서는 모든 종류의 Brush 메소드를 수정해야한다.

> 저자도 이 방식을 별로 안써봤고 다른방법을 통해 좀 더 명료하게 다차원 로직을 표현할 수 있다고함;;

### 분리(순차) 메시지

* 여러 단계로 구성되는 복잡한 알고리즘이 있다면, 관련된 단계드를 모으고 이를 수행하기 위해 메시지를 보낼 수 있다.
* 분리 메시지는 **이름을 잘지어야한다.**
	* 이름을 보고 이후 단계에서 어떤 일이 일어날 지 짐작할 수 있어야한다.
		* Example. life cycle method 
* 만약 이름짓기 어렵다면 분리메시지 패턴을 사용하는게 적합하지 않다는 신호일 수 있다.

### 되돌림 메시지

대칭성을 이용하면 코드의 가독성을 높일 수 있다.

```java
void compute() {
	input();
	helper.process(this);
	output();
}

// better 
void compute() {
	input();
	process(helper);		// 대칭성
	output();
}
```

하지만 되돌림 메시지를 과도하게 사용하는경우라면, 구현을 다른 곳으로 옮기는게 더 나을 수 있다.

```java
void input(Helper helper) {
	helper.input(this);
}

void ouput(Helper helper) {
	helper.output(this);
}

// better
void compute() {
	new Helper(this).compute();
}

Helper.compute() {
	input();
	process();
	output();
}
```

### 초청 메시지

* 코드를 짜면서 "이 부분은 하위에서 연산을 변형시키게 할거야."라는 의도가 있을 수 있다.
* 이럴땐 적당한 이름의 메시지를 통해 "변형의 여지를 마련했음"을 알려주는것이 좋다.

```
로직에 대한 기본 구현이 있다면 그것을 구현하고(=채워넣고),
그렇지않다면 추상메소드로 선언해서 하위에서 분명히! 반드시! 구현할 수 있게 하자.
```

### 설명 메시지

* 개발자의 의도와 구현을 구분하면 먼저 연산의 핵심을 파악하고, 필요한 경우에만 세부구현에 관심을 기울일 수 있다.
* 메시지를 사용하면 먼저 풀려는 문제의 이름을 반영하는 메시지를 보낸후, 문제 푸는 방식을 반영하는 메시지를 보내서 이 구분을 명시할 수 있다.

	* Example. 개발자의 의도: highlight, 구현: reverse

```java
highlight(Ractangle area) {
	reverse(area);
}
```

설명메시지의 목적은 **개발자의 의도를 좀 더 명확하게 전달하는것**이다.

## 예외 흐름

### 예외흐름

* 개발자는 주요흐름뿐 아니라 예외흐름에 대해서도 생각해야한다. 
* 예외흐름은 **주요 흐름의 명료성을 훼손하지 않는 범위 내에서** 명료하게 나타내라.
* 예외흐름은 조건절이나 예외를 사용해서 표현할 수 있다.

### 보조절

> 중간에 return 하는것.

```java
void initialize() {
	if(!isInitialized()) {
		...
	}
}

// better
void initialize() {
	if(isInitialized()) return;
	...
}
```

* `if-then-else`는 동등한 중요성을 갖고있는 제어 흐름을 표현할 때 유용하다.
* 보조절은 한쪽의 제어흐름이 다른 쪽보다 중요한 경우에 유용하다.

과거 프로그래밍 시절에는 단일 종료 지점을 갖고있어야했다. 

* 하지만 자바와 같이 짧은 메소드에 대부분 지역데이터만 사용하는 경우 이런 지침은 너무 보수적이다.
* 이런 이유로 보조절을 피할 이유는 없다.

보조절은 특히 여러개의 조건이 있을 경우 유용하다.

```java
void compute() {
	Server server = getServer();
	if(server == null) return;
	
	Client client = server.getClient();
	if(client == null) return;
	
	...
}
```
> 요즘은 이런 경우도 null 체크보다는 Optional을 사용하는게 유용한거같긴한데, 자바는 Optional 여러개이고 모두가 present인 경우 표현이 좀 까다로운것 같다ㅠㅠ 

## 예외

조건절과 메시지로 구현할 수 있는 코드를 예외로 구현하면 코드를 읽고 이해하기가 훨씬 어렵다.

* 호출된 메소드가 예외를 던지면 예외는 예외를 던진 메소드부터 예외를 처리할 메소드까지 거치게되는 모든 메소드의 설계와 구현에 영향을 미친다.
* 예외가 발생할 경우 다음에 수행되는 문장이 다른 메소드나 다른 객체, 다른 패키지에 있을 수도 있으므로 제어흐름을 따라가기 어려워진다.

그러므로 가능하면 순차적 구문, 메시지, 루프, 제어문을 사용해서 제어흐름을 표현하고 합리적으로 필요한 경우에만 예외를 사용하라. 

### 체크예외(ChekedException)

> 컴파일러가 잡아주는 Exception

* 예외의 위험성 중 하나는 "예외를 던졌을 때 아무도 그 예외를 받아주지 않으면 프로그램은 종료된다"는 것이다.
* 예외가 발생할 때는 사용자에게 어떤 일이 일어났는지 알려주기 위한 정보를 출력하는게 좋다.

자바에는 CheckedException이 있다.

* 컴파일러에 의해 체크되는 예외다.
* 체크예외를 넘겨받는 클래스는 모두 그 예외를 받거나(try-catch) 다른클래스로 넘겨줘야한다.(throw)

### 예외전달 

* 예외는 다양한 추상화 수준에서 발생할 수 있다. 
* 예상치 않은 시점에 하위 수준의 예외를 받아서 보여주는것은 혼란을 일으킨다.
* **예외를 포장해서** 로그에 메시지를 출력하면 예외 발생시 문제해결에 큰 도움이 된다.
