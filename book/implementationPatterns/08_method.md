# 08. 메소드

하나의 거대한 루틴에서는 

* 중요한 부분과 덜 중요한 부분을 구별하기 어렵다.
* 프로그램의 일부를 재사용하는것도 불가능하다.

프로그램 로직을 여러개의 메소드로 나누면

* 로직간의 연관성을 나타낼 수 있다. (연관이 있는 부분들이 같은 클래스나 패키지에 위치하니까)
* 메소드 이름을 통해 로직의 목적이 무엇인지 알 수 있다.
* 재사용문제를 해결할 수 있다.

로직을 메소드로 잘 나누기 위해서는 시간, 에너지, 창조력이 필요하다.

* 메소드의 크기, 목적, 이름 등을 신경써야한다.
* 짧은 메소드를 너무 많이 만들면 각 메소드에서 뭘 하는지 파악하기 어렵다.
* 하지만 메소드 수가 너무 적다면 중복이 많아지고 유연성이 떨어진다.

## 조합메소드

```
추상화 수준이 비슷한 메소드 호출로 하나의 메소드를 구성하라.
```

Example. 잘못 구성된 메소드 예

```java
void compute() {
	input();
	flags |= 0x0080;		// 추상화 수준이 다름
	output();
}
```

적당한 메소드 길이: 5~15줄

* 전체 구조를 읽을때는 긴 메소드가 좋다.
* 하지만 코드 세부사항을 이해하려할 때 긴 메소드는 오히려 방해가 된다. 
* 세부사항을 이해하고싶을때는 밀접하게 관련된 코드만 모아놓고 관련성이 떨어지는 코드는 분리하는 편이 좋다.
* 저자의 경우는 **짧은 메소드 단위로 코드를 구성할 때** 코드 이해가 가장 쉬웠다. 
* 상대적으로 독립적인 세부구현을 다른 메소드에게 맡길 수 있기 때문이다.

특화(오버라이드)

* 적당한 크기로 메소드를 작성하면 오버라이드가 용이하다.

일단 동작하는 코드를 만들고 메소드 구성방식을 결정하라.

* 어떤 경우에는 메소드를 어떻게 구성해야할 지 알고있다고 생각했지만, 실제 로직을 나누고 나면 코드를 읽기 어려울때도 있다.
* 이럴때는 모든 메소드를 인라인시켜서 커다란 메소드를 만든 후 다시 메소드를 나누는 방법을 사용한다.

## 의도제시형 이름

```
메소드 이름을 통해 메소드의 의도를 전달하자.
```

Example. 메소드 이름에 의도를 담은 예

```java
Customer.linearCustomerSearch(String id);	// tmi
Customer.find(String id);	//의도가 명확히 드러난다.
```

관련된 모든 정보를 메소드 이름에 표현하는것이 능사는 아니다.

* **구현 전략이 사용자에게 중요하지않다면 메소드명에서 빼라.**
* 구현 전략이 궁금한 사용자는 메소드 본문을 보고 어떻게 구현됐는지 확인하면 된다.

메소드의 이름을 지을때는 **그 메소드를 호출하는 입장에서 생각해보라.**

* 왜 이 메소드를 사용해야하는가?
* 메소드 이름에서 이 질문에 대한 답을 얻을 수 있어야한다.

기존 인터페이스와 비슷한 구현이라면, 인터페이스에 사용된 것과 같은 이름을 사용하라.

Example. iterator 역할을 하는 무언가를 구현한다면

```
실제 Iterator 인터페이스를 구현하는것이 아니더라도
Iterator 인터페이스를 본따서 hasNext(), next()같은 메소드 이름을 사용하라.
```

## 메소드 가시성

public, package, protected, private 역시 프로그래머의 의도를 전달한다.

가시성을 선택할 때는 두가지 비용을 고려해야한다.

1. 미래의 유연성

	* 외부에 드러나는 인터페이스가 적으면 미래에 인터페이스를 수정하는것은 어렵지 않다.
 
2. 객체를 사용하는데 들어가는 비용

	* 노출된 인터페이스가 적은 객체를 사용할 경우, 사용하는 측에서는 필요 이상으로 많은 작업을 해야한다.

저자가 사용하는 전략은 **가급적 가시성을 낮추는것**이다. (= 왠만하면 private으로)

```
먼저 가장 제한적인 가시성을 선택한 후, 필요에 따라 조금씩 가시성을 높여라.
```

### final 

메소드를 final로 선언하는 문제는 가시성을 선택하는 문제와 비슷하다.

* 저자는 개인적으로 final을 사용하지 않는다.
* 오버라이드해서 사용하고 싶은 메소드가 final로 선언돼있어서 실망했던 경우도 있다.

> 이 부분에 대해 어떻게생각하시나요!

### static

메소드를 static으로 선언하면 인스턴스 없이도 메소드에 접근할 수 있다. 

* 이런 메소드에는 복잡한 로직을 구현하기에 적합하지 않다. (Example. Utils)

## 메소드 객체

메소드 객체는 복잡하게 꼬여있는 메소드를 읽기 쉽고 명확하고 세부구현 전달이 쉽도록 바꿔준다.

먼저 파라미터 여러개와 임시변수를 사용하는 긴 메서드가 있다면 메소드 객체를 고려해보자.

1. 메소드 이름을 따서 클래스이름을 정한다.

```
complexCalculation() -> ComplexCalculator
```

2. 메소드에서 사용하는 각 파라미터, 지역변수, 필드를 새로운 **객체의 필드로** 생성한다.
3. 본래 메소드의 파라미터와 메소드에서 사용하는 필드를 파라미터로 취하는 **생성자를** 만든다.
4. 본래 메소드를 새로운 클래스의 calculate()라는 메소드로 복사한다. 
5. 기존 메소드의 본문을 새로운 객체의 인스턴스를 생성한 후 calculate()를 호출하는 코드로 바꾼다.

```java
long complexCalculation() {
	return new ComplexCalculator().calculate
}
```

6. 본래 메소드에 필드를 설정하는 부분이 있었다면 calculate()가 반환된 후에 설정해준다.

```java
ComplexCalculator calculator = new ComplexCalculator();
calculator.calculate();
mean = calculator.mean;	
```

7. 리팩토링된 코드가 기존코드와 똑같이 동작하는지 확인한다.

## 오버라이드

상위 클래스 코드가 작고 밀접한 코드로 나뉘어있다면, 오버라이드 하기 쉽다.

오버라이드를 사용한다고 상위클래스와 하위클래스의 메소드 중 하나를 선택해야만 하는것은 아니다.

* `super.method()`를 호출해서 상위클래스의 메소드를 사용할 수 있기 때문이다.
* 하지만 **상위클래스 메소드는 하위클래스 메소드 중 같은 이름의 메소드에서만 호출하는게 좋다.**
* 하나의 메소드에서 여러 상위클래스를 호출해야하는 경우라면, 제어흐름을 재구성해야한다.

너무 방대한 상위클래스 메소드는 딜레마를 낳는다. 

> 상속은 엄청난 강결합이라고 생각한다.
> 중복코드는 줄일수 있겠지만 오버라이드를 계속 생각해야하고 하위클래스, 상위클래스 두개의 동작을 잘 인지하면서 써야하니까. 어떻게 생각하시나요!

## 오버로드

서로 다른 파라미터를 사용해서 같은 메소드를 선언하면 "이 메소드를 사용할 수 있는 다양한 포맷이 존재한다"는 의미이다.

> 개인적으로는 (1,2,null)이렇게 호출하는거보다 오버로드로 메소드 두개 만드는것을 선호하는데 어떤가요?

단점

* 이 메소드를 사용하면 어떻게되나?라는 질문에 메소드 이름 뿐 아니라 파라미터도 유심히 살펴봐야한다.

메소드 오버로드는 **파라미터 타입만 다를 뿐, 같은 연산을 수행해야한다.**

* 의도가 다르다면 새로운 이름을 갖는 메소드를 사용하는것이 좋다.

## 메소드 반환타입

```
반환타입으로 concreate 클래스나 primitive type 보다는 의도를 드러낼 수 있는 가장 추상적인 타입을 사용하라.

Example. List 대신 Collection을 반환하라.
```

반환타입을 일반화하면 세부 구현을 숨길 수 있다.

여러 관련 메소드에서 각기 다른 구상클래스를 반환하게 되는 경우, 유사점을 인터페이스로 추출해서 이 인터페이스를 반환하게 하는것이 좋다.

## 메소드 주석

```
코드의 이름, 구조로 정보를 전달하는게 좋지만
이걸로 부족할때는 주석을 사용해서 전달하라.
```

단, 진짜 주석이 필요한 상황인지 생각해보자.

* 대부분의 경우 주석은 이미 알 수 있는 정보를 중복해서 나타낼 뿐 커뮤니케이션에 도움ㅇ르 주지 못한다.
* 또한 주석과 코드가 달라졌다고해도 이를 바로 알 수 있는 방법이 없다.

주석에 적으려던 정보를 **자동화된 테스트**로 전달할 수도 있다.

* 테스트 작성은 소중한 설계 연습이 된다.
* 테스트 동작을 통해 테스트와 코드의 일관성을 보장해줄 수도 있다.

## 도우미 메소드

긴 메소드를 여러개의 작은 메소드로 나누게 되면 짧은 도우미 메소드가 필요하다.

### 목적1. 코드를 좀 더 읽기 좋게 만들기 위해

* 당장 관련도가 떨어지는 세부 구현을 숨기고, 
* 메소드 이름에 프로그래머의 의도를 나타냄으로써 
* 복잡하고 거대한 연산 코드를 좀 더 **읽기 좋게 하기 위함**이다.

도우미 메소드는 보통 private으로 선언되며, 하위클래스에서 사용이 필요한 경우 protected로 선언되기도 한다.

Example. 클래스의 생성자를 반환하는 일만 수행하는 도우미 메소드

```java
return getTestConstructor().newInstance();
```

* 하위클래스에서 생성자를 오버라이드하는 경우, 이러한 도우미 메소드를 사용하는것은 정당화될 수 있다.
* 하지만 메소드의 로직이 불명확해지는 경우라면 도우미 메소드를 제거하는게 낫다.

### 목적2. 공용구문을 제거하기 위해

조그마한 특정 연산이 필요할때마다 도우미메소드를 호출하면 해당 구문의 수정은 쉽다. 도우미메소드 이름을 통해 프로그래머의 의도가 전달되기도 한다.

하지만 같은 2-3줄의 코드가 여러군데에서 반복된다면, 프로그래머의 의도를 파악하기도 어렵고 코드 수정도 어려워진다.

## 디버그 출력 메소드

객체를 문자열로 나타내면 여러가지 좋은 점이 있다.

1. 어떤 객체의 내용을 사용자에게 표현할 때 편리하고
2. 저장 후 다시 읽어와서 사용하기에도 좋으며
3. 프로그래머에게 객체 내부 구현을 표현할 수도 있다.

Obejct에 있는 toString 메소드

* 고품질의 디버그 메시지를 출력하면 얻을 수 있는 장점이 많다. toString을 잘 활용하면 이런 점에서 좋다.
* 하지만 toString()메소드는 public 메소드이기 때문에 남용하기 쉽다.
	* 여러 개발자가 각자 찍고싶은 모양에 따라 toString()을 마구 수정하면 코드가 망가지기 쉽다.
	* 이런 상황을 방지하기 위해 사용자가 원하는 프로토콜을 모두 포함하도록 만들자.

```
toString()은 프로그래머에게 객체의 정보를 알려주기 위해서 사용하는것이 좋다.
그밖의 문자열 정보는 다른 메소드나 클래스를 통해 표현하라.
```

## 변환

변환을 가장 효과적으로 표현하기 위해서는 몇가지 기술적 사항을 고려해야한다.

1. 변환이얼마나 필요한지
	* 하나의 객체가 다른 하나의 객체로 변환되는 경우만 고려한다면 간단한방법을 사용해도 괜찮다.
	
2. 클래스간의 의존성
	* 변환을 편리하게 표현하기 위해 새로운 의존성을 만드는것은 바람직하지 않다.

구현

1. 기존 객체의 정보를 복사해서 새로운 타입의 실제 객체를 생성한다.
2. 때로는 기존 객체에서 정보를 복사하지 않고 대상 객체에 대한 인터페이스를 구현할수도 있다.
3. 때로는 실제 변환을 하지 않고 두 객체간의 공통 인터페이스를 찾아서 인터페이스를 통해 코드를 작성할 수도 있다.

### 변환메소드

```
기존 객체에 메소드를 추가해서 변환을 나타낼 수 있다.
```

Example. Polar -> Cartesian 

```java
class Polar {
	Cartesian asCartesian() { ... }
}
```

장점

* 읽기 쉽다.

단점

* 하나의 변환 메소드를 만들기 위해서는 원본 객체의 프로토콜을 변경해야한다. 
* 변환메소드는 원본 객체와 대상객체 사이에 **의존성**을 생성한다.
	*  원래 의존성이 없었는데 변환메소드 때문에 의존성이 생기는것은 바람직하지 않다.
* 변환메소드수가 제한되지 않는 경우 읽기 어려워진다. 
	* 20개의 asXX() 메소드를 갖고있는 클래스라면,
	* 변환 대신 클라이언트측에서 원본객체를 다룰수 있게 하는편이 낫다.

이러한 단점들로 인해 변환메소드는 **자주 사용하지 않으며, 유사한 타입의 객체 사이의 변환**에만 사용된다.
대개의 경우 변환메소드보다는 **변환생성자**사용을 선언한다.

> 변환생성자나 Mapper 클래스를 따로 두는 방법.

### 변환생성자

```
원본객체를 파라미터로 받아서 => 대상객체를 반환한다.
```

하나의 원본객체를 여러 다른 대상객체로 변환할때 유용하다. 변환하는 경우의 수가 많더라도 원본객체의 코드가 지저분해지지 않기 때문이다.

> 대상객체마다 의존성이 생기는건 괜찮은건가?.. 그냥 선택의 문제인건가

Example.

```
String.asFile() 		// 이러면 너무많아지니까
File(String name) 	// 이렇게
```

## 생성

크기가 작은 프로그램은 큰 프로그램에 비해 수정하기 쉽다. 크기가 큰 프로그램을 여러 개의 객체로 나누면 수정비용이 낮아진다.

객체생성은 "연산에 관련된 세부 내용은 당장 알 필요 없다"는 메시지를 전달해준다.

의미있는 객체생성을 위해서는 명확하고 직접적인 표현과 유연성 사이에서 균형을 잡아야한다. 

### 완결생성자

```
생성자에서 객체를 연산가능한 상태로 반환해서 -> 연산을 위한 전제조건을 전달하자.
객체를 설정하는 방법이 여러가지라면 각경우마다 제대로된 객채를 반환하는 생성자를 제공하라.
```

Example. Ractangle 연산에 width, height가 필요할때

```java
Rectangle box1 = new Ractangle();
box.setWitdh(10);
box.setHeight(20);
// => 올바로 동작하기 위해 정확히 어떤 파라미터들이 필요한지 파악이 어렵다.

Ractangle box2 = new Racgangle(10, 20);
// => width, height가 필요하구나! 파악하기 쉽다.
```

> 이펙티브자바에서도 점진적생성자였나? 나온다.

코드를 좀 더 추상적으로 가져가고싶다면 Factory 메소드를 활용하라.

완결생성자를 구현할때는 모든 생성자가 동일한 하나의 생성자를 사용해서 모든 초기화를 하도록 해라.

* 이렇게하면 어떤 생성자를 사용하더라도 클래스의 올바는 동작을 위해 필요한 변치않는 부분을 적절히 보장할 수 있고,
* 앞으로 이 클래스를 수정해야하는 사람한테도 명확히 전달할 수 있다.

### Factory 메소드

팩토리메소드는 생성자에 비해 몇가지 장점이 있다.

1. 추상타입을 반환할 수 있으며
2. 의도가 담긴 메소드 이름을 가질 수 있다.
3. (추가) 불필요한 인스턴스 생성 방지할 수 있다. (Example. Boolean.TRUE)

단점

1. (비교적) 복잡성이 증가한다.

팩토리메소드는 객체를 생성하는것보다 복잡한 작업이 필요한 경우 유용하다.

* 객체를 캐쉬에 저장해놓거나
* 런타임에 타입이 결정되는 하위클래스를 반환하거나 등등

```
평범한 객체생성의 경우에는 생성자를 사용하고,
객체생성+다른의도가 필요할때는 팩토리메서드를 사용하라.
```

### 내부공장

도우미 객체 생성을 private으로 하고싶지만, 객체 생성과정이 복잡하거나 하위클래스에 따라 달라지는경우 

```
새로운 객체를 생성하고 반환하는 메소드를 만들자.
```

Example.

```
getX() {
	if(x==null) 
		x = buildX();		// 내부공장
	return x;
}

```

> Response 객체 조립할때 이런 모양을 많이 사용하고있다.

## 컬렉션 접근자 메소드

컬렉션을 반환하는 getter 는 주의해야한다.

```java
List<Book> getBooks() {
	return books;
}
```

* 사용자가 컬렉션을 직접 조작하게되므로, 컬렉션 데이터에 의존적인 객체 내부 상태가 꼬일 수 있다.
* 컬렉션을 직접 반환해서 모든 작업을 허용하면 해당 객체에 대한 풍부하고 의미있는 프로토콜을 만들 기회를 상실하게 된다.

> 이거 무슨말인지 모르겠다 ㅠㅠ

해법1. 수정할 수 없는 컬렉션 형태로 바꿔서 반환하자.

```java
List<Book> getBooks() {
	return Collections.unmodifiableList(books);
}
```

해법2. 컬렉션에 제한적이지만 의미있는 메소드를 만들자.

```java
int bookCount() {
	return books.size();
}

// 사용자가 컬렉션 원소에 하나씩 접근해야한다면
Iterator getBooks() {
	return books.iterator();
}
```

* 클라이언트에서 remove()만 호출하지 않는다면 컬렉션이 수정되는것을 막을 수 있다.
* 코드로 막고싶다면 컬렉션 원소를 제거할 경우 예외를 던지는 Iterator를 반환하라. (146p 예제코드 참고)
* 단, 런타임 Exception은 위험하고 디버깅하기 어렵다.

## boolean 설정 메소드

boolean 상태를 설정하는 가장 간단한 해법은 setter를 사용하는것이다.

```java
void setValid(boolean state) { ... }
```

하지만 설정 메소드의 인자가 언제나 true/false라면 각 boolean 상태별로 method를 제공해서 인터페이스를 더욱 명확하게 할 수 있다.

```java
void valid() { ... }
void invalid() { ... }
```

* 새로운 인터페이스를 사용하는 코드가 더 읽기 쉽고, 언제 어떤 상태로 변하는지 알기 쉽다.
* 하지만 호출하는쪽에서 `x ? valid() : invalid()` 이런식으로 사용된다면 `setValidity(boolean)` 메소드를 제공하는게 낫다.

## 질의 메소드

다른 객체의 상태에 따라 결정을 내려야할 때 be/have 동사를 사용해서 이름을 짓자.

```
widget.isVisible();
```

어떤 객체가 다른 객체의 상태에 의존적인 로직을 많이갖고있다면, 이것은 로직의 위치에 문제가 있다는 신호다.

Example.

```java
if(widget.isVisible()) widget.doSomthing();
else widget.doSomthingElse();
```

* 이런 경우는 widget 객체에 적당한 메소드 하나로 만드는게 낫다.

## 동등성 메소드

객체가 동등한지 비교해야하는 경우 `equals(), hashCode()`를 구현하라.

* 동등한 객체는 같은 해쉬값을 가져야하므로, hashCode() 구현에는 equals() 구현에 쓰인 데이터만을 사용해야한다.

보통 타입클래스일때 equals()를 구현하면 유용하다.

equals()를 구현시 지켜야하는 규약이 많다.

* 이 규칙을 잘 숙지하고 지켜야지, 그렇지않으면 이상한 결함이 발생할 수 있다.

## 취득 메소드: getter 

저자는 공개수준이 높은 getter를 좋아하지 않지만 몇가지 예외상황은 인정한다.

* 여러 객체를 이용해서 알고리즘ㅇ르 구현하는 경우
	* 알고리즘은 데이터접근을 위해 public getter를 필요로한다.
* public 메소드를 필요로 하는데, 그 메소드가 하는 일이 필드값을 반환하는 경우
* 다른 tool에서 getter method를 요구하는 경우. 

## 설정 메소드: setter

setter 공개범위를 높이는것을 더 주의해야한다.

### setter 메소드의 이름은 의도가 아닌 구현에 의해 정해져야햔다.

* 값을 설정해서 클라이언트가 어떤 문제를 해결할 수 있는지 이해하고, 그 문제를 직접 해결할 수 있는 메소드를 제공하라.

Example.

```java
p.setJustification(Paragraph.CENTERED);

// better
p.centered(); 
// 이 method 안에서 setJustification(Paragraph.CENTERED)
```

* 개선 전 코드는 클라이언트에 내부 구현을 노출시키고있다. 
* 개선 후 코드는 내부 구현을 숨겼고, 읽기도 쉽다.

### private setter 를 사용할 수도 있다.

* 의존적인 정보를 업데이트할 때 유용하다.
* 어떤 데이터가 변경될 경우, 어떤 의존적인 데이터가 변경되어야하는지 명확하게 보여줄 수 있다.

Example.

```java 
private void setJustification(...) {
	...
	redisplay();
}
```

### setter 를 사용하면 코드에 문제가 발생하기 쉽다.

한가지 원칙은 가급적 외부에서 setter 사용을 피하는 것이다.
어떤 tool에서 setter를 필요로 하는 경우라면 주석으로 "tool 전용"을 붙이는게 좋다.

## 안전한 복사

getter, setter 사용시 alias문제가 발생할 수 있다.

* alias 문제: 2개의 객체가 다른 객체에 대해 배타적인 접근권이 있다고 가정하는것

### 방안: 객체를 반환하거나 저장하기 전에 복사본 만들기(안전한 복사)

```java
List<Book> getBooks() {
	List<Book> result = new ArrayList<Book>();
	result.addAll(books);
	return result;
}

void setBooks(List<Book> newBooks) {
	books = new ArrayList<Book>();
	books.addAll(newBooks);
}
```

안전한 복사는 통제할 수 없는 외부 접근에서 코드를 보호하는 일시적인 해결책일 뿐이다.
따라서 가급적 어떤 구현의 핵심기법으로 사용하는것은 피하는 편이 낫다.
immutable object와 적합한 조합메소드를 통해 해결하는것이 낫다.