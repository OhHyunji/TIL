# 9. 더 큰 설계문제 

8장에서는 matches() 메서드를 좀 더 깔끔한 하위메서드 몇개로 리팩토링했다. 

* 작은 코드들을 계속해서 리팩토링하는것은 코드 유지보수비용을 지속적으로 낮춰준다.

이번장에서든 좀 더 큰 설계관점에 대해 이야기해볼것이다.

* 단일책임원칙(SRP)에 초점을 맞추는데, 이는 좀 더 작은 클래스를 만들어 유연성, 테스트용이성을 높여준다.
* 명령-질의 분리에 대해서도 알아보는데, 이는 side effect를 만들고 동시에 값을 반환하여 생기는 문제들로부터 보호해준다.

## 9.1 Profile 클래스와 SRP

example. 지금까지 리팩토링한 Profile 클래스 살펴보기 (p.182)

* 100줄이 안되는 코드로, 과도하게 크거나 극도로 복잡하지는 않지만 
* 이상적이지 않은 설계 포인트가 몇군데 있다.
	* 객체지향클래스 설계의 단일책임원칙(SRP)을 위반하고있다.
	* SRP는 "클래스 변경시 단 한가지 이유만 있어야함"을 의미한다.
	* 클래스에 많은 책임이 있을수록 클래스에 있는 코드를 변경할 때 기존의 다른동작들을 깨기 쉽다.
	* 더 작고 집중화된 클래스는 재활용에도 좋다.

참고: SOLID 클래스 설계원칙

* 단일책임 원칙(SRP)
	* 클래스는 변경할 때 한가지 이유만 있어야한다.
	* 클래스는 작고 단일목적을 추구한다.
* 개방폐쇄 원칙(OCP)
	* 클래스는 확장에 열려있고 변경에는 닫혀있어야한다.
	* 기존클래스의 변경을 최소화해야한다. 
* 리스코프 치환 원칙(LSP)
	* 하위타입은 반드시 상위타입을 대체할 수 있어야한다.
	* 클라이언트 입장에서 오버라이딩한 메서드가 기능을 깨면 안된다.
* 인터페이스 분리 원칙(ISP)
	* 클라이언트는 필요하지 않은 메서드에 의존하면 안된다.
	* 커다란 인터페이스도 여러개의 작은 인터페이스로 분할하세요.
* 의존성 역전 원칙(DIP)
	* 고수준 모듈은 저수준 모듈을 의존해서는 안된다. 둘다 추상클래스에 의존해야한다.
	* 추상클래스는 구체클래스에 의존해서는 안된ㄴ다.
	* 구체클래슨는 추상클래스에 의존해야한다.

## 9.2 새로운 클래스 추출

Profile 클래스는 두개의 책임을 갖고있다.

1. 프로파일에 관한 정보 추적하기
2. 조건집합이 프로파일에 매칭되는지 판단하기

```java
// before
public boolean matches(Criteria criteria) {
    calculateScore(criteria);
 
    if (doesNotMeetAnyMustMatchCriterion(criteria)) {
        return false;
    }
 
    return anyMatches(criteria);
}
```

1단계. calculateScore() 로직을 MatchSet 클래스로 이동해보자.

```java
public boolean matches(Criteria criteria) {
    score = new MatchSet(answers, criteria).getScore();
 
    if (doesNotMeetAnyMustMatchCriterion(criteria)) {
        return false;
    }
 
    return anyMatches(criteria);
}
```

* calculateScore 내부에서 사용하던 private 메소드들도 MatchSet으로 이동했다.

리팩토링결과

* MatchSet 클래스는 매칭과 관련된 코드들을 고립시켰고, 코드가 더 단순해졌다.
* Profile 클래스도 단순해졌다.

설계는 코드를 변경하는 모든곳에 존재한ㄴ다. 

* 단순히 클래스 수준의 상호작용이 아니라, 유지보수의 모든 측면에 집중하세요.

## 9.3 명령-질의 분리

다시 Profile 클래스의 matches() 메소드를 살펴보면

```java
public boolean matches(Criteria criteria) {
	MatchSet matchSet = new MatchSet(answers, criteria);
	score = matchSet.getScore();
	return matchSet.matches();
}
```

* 계산된 점수를 Profile객체의 필드 score에 저장하고있다.
* Profile 클래스의 맥락과 맞지 않다. 어색하다. 
* Profile 객체는 단일점수를 갖지 않으며, 조건과 매칭될때만 점수가 산출된다.

이런 사이드이팩트는 여러가지 문제를 야기한다.

* 점수를 원하면 matches()메서드를 호출해야한다는 점을 알아야한다,.
* 이는 직관에 어긋난다. 

### 아무튼, 명령-질의 분리 원칙

* 메서드는 명령을 실행하거나(사이드이펙트를 생성하는 어떤 작업 실행)
* 질의에 대답(어떤 값 반환)할 수 있으며, 
* 두 작업을 모두하면 안된다.

명령-질의 분리 원칙을 위반하는 전통적인 예제: `java.util.Iterator` 인터페이스

* next() 메소드는 다음객체를 가리키고, 현재 객체 포인터를 증가시킨다.
* 부주의한 호출은 결함으로 이어질 수 있다.

이런 문제를 위해 Profile 클래스에서 score()메서드와 score필드를 제거하자. 

* example. Profile.java (p.192)

## 9.4 단위테스트의 유지보수비용

리팩토링은 코드동작을 변경하지 않고 코드 구현만 바꾸는 활동이고, 테스트코드는 그 동작을 보증한다.

* 코드를 바꾸면 테스트가 깨질 수 있는데, 이런 경우 단위테스트에 유지보수비용이 필요하다.
* 보통 돌아오는 가치가 훨씬 크기 때문에 깨진 테스트코드를 고치는 비용을 받아들인다.
* 만약 많은 테스트가 동시에 깨진다면 설계에 문제가 많을것이다.

### 9.4.1 자신을 보호하는 방법

중복을 없애자. _왜냐하면..._

1. 중복코드가 많으면 코드 읽기가 어렵다.

	* 3줄로 Answer 객체를 생성하고 채우면 코드를 읽는 사람은 3줄을 이동하면서 이해해야한다.
	* createMatchingAnswer()같은 도우미메소드를 활용하면 더 잘읽힐거다.

2. 중복코드를 작은 코드조각으로 나누고 메서드로 추출하면 그 코드조각들을 변경해야할 때 미치는 영향을 최소화할 수 있다.

	* 단일장소 한곳만 수정하면 되니까.

커다란 클래스를 분할하세요.

*  SRP를 위반하면 클래스는 점점 더 커지고, 다른클래스에 대한 의존성이 커지고, 테스트를 설정하는데 더 많은 노력이 필요하다.
*  private 메서드(=구현 세부사항)를 테스트하려는 충동은 클래스가 필요 이상으로 커졌다는 또다른 힌트다.
*  private 메서드가 자꾸 늘어나면 내부동작을 새 클래스로 옮기고 public으로 만드는것이 좋다. _작은 클래스로 쪼개라_
*  단위테스트가 어려워보인다면 그것도 좋은 힌트다. 설계를 개선해서 단위테스트를 쉽게 만들어라. 그러면 단위테스트 유지비용을 줄일 수 있다.

시스템 설계, 코드품질이 나쁠수록 단위테스트의 유지보수 비용은 증가한다.

### 9.4.2 깨진 테스트 고치기 

example. MatchSetTest 깨진 테스트를 고쳐나가자 (p.196)

## 9.5 다른 설계에 관한 생각들 

example. 답변들의 저장소를 AnswerCollecion 클래스로 분리 (p.198~)

점진적으로 리팩토링하며, 작게 변경하고 테스트를 실행하자.


좋은 말씀

* 시스템 설계에 대해 비판적인 눈을 유지하고, "최상의 설계는 없다"는 것을 명심하세요.
* 시스템을 깨끗하게 하는 책임은 결코 끝이 없습니다.

## 9.6 마치며

설계를 지속적으로 개선해나가는 자신감을 키우기 위해 단위테스트의 커버리지를 높이세요.

설계에 관한 커다란 개념들을 가능한 많이 알아두어야하고, 설계에 관한 작은 개념들과 작은 코드리팩토링이 어떻게 커다란 차이를 만들어내는지도 이해해야한다.

작은 클래스와 메서드들을 만드세요.


