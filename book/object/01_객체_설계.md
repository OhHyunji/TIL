# 00. 들어가며

## 프로그래밍 패러다임

프로그래밍 패러다임은 개발자 공동체가 **동일한 프로그래밍 스타일과 모델을 공유할 수 있게** 함으로써 불필요한 부분에 대한 의견 충돌을 방지한다.

이 책을 읽으면 객체지향 패러다임이라는 용어를 사용할 때 어느정도 서로 유사한 그림을 머릿속에 그릴 수 있을것이다.

각 패러다임과 그 패러다임을 채용한 언어는 특정한 종류의 문제를 해결하는 데 필요한 일련의 개념들을 지원한다. 이것이 프로그래밍 언어와 프로그래밍 패러다임을 분리해서 설명할 수 없는 이유다.

# 01. 객체, 설계

이 책은 **훌륭한 객체지향 프로그램을 설계하고 유지보수하는 데 필요한 원칙과 기법**을 설명하기위해 쓰여진 책이다. 개념이나 이론보다는 코드를 이용해서 객체지향의 다양안 측면을 설명하려고 노력할것이다.

## 티켓판매 애플리케이션 구현하기

> 9p. 예제코드 읽어보기

## 무엇이 문제인가

모든 모듈은

1. 제대로 실행돼야하고,
2. 변경이 용이해야하며
3. 이해하기 쉬워야한다.

이 예제코드가 어디가 문제인지 자세히 살펴보자.

### 예상을 빗나가는 코드 

1. 우리의 상식과 너무 다른 동작이다.
	* 소극장이 관람객의 가방을 열어서 확인한다.
2. 여러가지 세부적인 내용들을 한꺼번에 기억하고있어야한다.
	* Theater의 enter 메서드를 이해하기 위해서는 이 모든것을 한꺼번에 기억하고있어야한다.
		* Audience가 Bag을 가지고있고
		* Bag 안에는 현금과 티켓이 있으며
		* TicketSeller가 TicketOffice에서 티켓을 판매하고
		* TicketOffice에서 돈과 티켓을 가지고있다.

### 변경에 취약한 코드

의존성이란 "어떤 객체가 변경될 때 그 객체에 의존하는 객체도 함께 변경될 수 있다"는 얘기다.

* 그렇다고 객체 사이의 의존성을 완전히 없애는 것이 정답은 아니다. 
* 객체지향 설계는 서로 의존하면서 협력하는 **객체들의 공동체**를 구축하는것이다.
* **최소한의 의존성만 유지하고 불필요한 의존성을 제거해야한다.**
* 두 객체사이의 결합도가 높을수록 함께 변경될 확률도 높아지기 때문에 변경이 어려워진다. 
* 결합도를 낮춰 변경이 용이한 설계를 만들어야한다.

이 예제코드는 필요한 기능은 수행하지만 변경용이성, 의사소통면에서는 별로다.

## 설계 개선하기

### 자율성을 높이자

설계를 변경하기 어려운 이유는 Theater가 Audience, TicketSeller뿐만 아니라 Audience 소유의 Bag과 TicketSeller가 근무하는 TicketOffice까지 마음대로 접근할 수 있기 때문이다.

Audience, TicketSeller가 직접 Bag, TicketOffice를 처리하는 자율적인 존재가 되도록 설계를 변경하자.

> 18p. 예제코드 읽어보기 

이처럼 객체 내부의 세부적인 사항을 감추는것을 **캡슐화(encapsulation)**라한다. 

 * 캡슐화의 목적은 **변경하기 쉬운 객체**를 만드는것이다.
 * 캡슐화를 통해 객체 내부사항에 대한 접근을 제한하면 객체와 객체 사이의 결합도가 낮아지기 때문에 변경이 쉽다.

객체를 **인터페이스와 구현으로 나누고 인터페이스만 공개하는것**은

* 객체 사이의 결합도를 낮추고
* 변경하기 쉬운 코드를 작성하기 위한 가장 기본적인 설계원칙이다.

> p.22 예제코드 읽어보기: 객체들을 좀 더 자율적인 존재로 바꾸는 중..

### 무엇이 개선되었는가

> p.17, p.24 그림(클래스다이어그램) 비교

### 어떻게 한 것인가

객체의 자율성을 높였다. 그 결과 변경용이하고 이해하기 쉬운 코드가 되었다.

### 캡슐화와 응집도

핵심은 

1. 객체 내부의 상태를 캡슐화하고
2. 객체간에 오직 메시지를 통해서만 상호작용하도록

만드는것이다.

밀접하게 연관된 작업만을 수행하고, 연관성 없는 작업은 다른 객체에게 위임하는 객체를 **응집도(cohesion)가 높다**고 말한다.

* 응집도를 높이기 위해서 **객체는 자신의 데이터를 스스로 책임지는 자율적인 존재**여야 한다.
* 훌륭한 객체지향 설계란, **메시지를 통해서만 협력하는 자율적인 객체들의 공동체**를 만드는것이다.

### 절차지향과 객체지향

#### 절차지향

* 데이터, 프로세스를 별도의 모듈에 위치시킨다.
	* 개선 전	 코드가 절차지향 설계 코드다.
	* 모든 처리가 하나의 클래스 안에 위치하고(Theater), 나머지 클래스는 단지 데이터역할만 수행하는 구조다.

* 변경하기 쉬운 설계는 한번에 하나의 클래스만 변경할 수 있는 설계다.
	* 절차적 프로그래밍은 프로세스가 모든 데이터에 의존하기 때문에 변경에 취약하다. (Theater에서 다른 클래스들을 모두 참조하고있었음.)

#### 객체지향

* 데이터, 프로세스를 동일한 모듈 내부에 위치시킨다.
	* 개선 후 코드가 객체지향 설계 코드다.
	* 개선 후에는 Audience, TicketSeller가 직접 Bag, TicketOffice를 처리하는 자율적인 존재가 되었다.
* 객체지향 코드는 자신의 문제를 스스로 처리하기 때문에 이해하기 쉽고, 객체 내부의 변경이 객체 외부로 파급되지 않기 때문에 변경이 용이하다.

### 책임의 이동(shift of responsibility)

> 28p. 절차적 프로그래밍, 객체지향 프로그래밍 그림 참고
> 
> 절차적 프로그래밍에서는 책임이 한곳에 집중되어있다.
> 
> * 개선 전 코드는 Theater에 작업흐름이 집중돼있다.
> 
> 객체지향 프로그래밍에서는 책임을 쪼개서 각 객체한테 할당한다.
> 
> * 개선 후 코드에서는 책임(작업흐름)이 Theater, TicketSeller, Audience에 분산돼있다.


객체지향에서는

* 객체지향 설계에서는 각 객체가 자신이 맡은 일을 스스로 처리한다.
* 객체지향 애플리케이션은 스스로 책임을 수행하는 자율적인 객체들의 공동체다.
* 이러한 관점에서 객체지향 프로그래밍을 흔히 "데이터와 프로세스를 하나의 단위로 통합하는것"이라 표현하기도 한다.
	
```
객체지향 안에는 단순히 데이터와 프로세스를 하나의 객체 안으로 모으는것 그 이상의 무언가가 있다.

객체지향 설계의 핵심은 적절한 객체에 적절한 책임을 할당하는것이다.
객체는 다른 객체와 협력하면서 자신의 역할(책임)을 수행해야한다.
따라서 객체가 어떤 데이터를 가지느냐 보다, 객체에 어떤 책임을 할당할것이냐에 초점을 맞춰야한다.
적절한 객체에 적절한 책임을 할당하면 이해하기 쉽고 읽기 쉬운 코드가 된다.

의존성은 설계를 어렵게만든다.
해결방법은 불필요한 의존성을 제거해서 객체 사이의 결합도를 낮추는것이다.

이 과정에서 캡슐화 개념이 등장하는데, 세부사항을 객체 내부로 캡슐화하면 
1. 객체의 자율성이 높아지고 
2. 응집도 높은 객체들의 공동체를 만들 수 있다.
```

### 더 개선할 수 있다

> 29p. 예제코드 읽어보기 

이 예제를 통해 우리는 두가지 사실을 알게되었다.

1. 어떤 기능을 설게하는 방법은 한가지 이상일 수 있다.
2. 동일한 기능을 여러가지 방법으로 설계할 수 있기 때문에 결국 설계는 **트레이드오프의 산물**이다.

어떤 경우에도 모든 사람들을 만족시킬 수 있는 설계를 만들수는 없다. (cc. 시드...)

```
훌륭한 설계는 적절한 트레이드오프의 결과물이다. 
```

## 객체지향 설계

### 설계가 왜 필요한가

설계란 코드를 배치하는 것이다.

* 설계를 구현과 떨어트려서 이야기하는것은 불가능하다.
* 설계는 **코드를 작성하는 매 순간 코드를 어떻게 배치할것인지** 결정하는 과정에서 나오기 때문이다.

좋은 설계란

* 오늘 완성해야 하는 기능을 구현하는 코드를 짜야 하는 동시에
* 내일 쉽게 변경할 수 있는 코드를 짜야한다.

변경용이성이 중요한 이유는

1. 요구사항이 항상 변경되기 때문이다.
2. 코드를 변경할 때 버그가 생길 가능성이 높기 때문이다.
	* 코드를 수정하지 않으면 버그는 발생하지 않는다.

요구사항 변경은 필연적으로 코드 수정을 초래하고, 코드 수정은 버그가 발생할 가능성을 높인다. 

### 객체지향 설계

우리가 진정으로 원하는 것은 변경에 유연하게 대응할 수 있는 코드다.

* 객체지향 프로그래밍은 의존성을 효율적으로 통제할 수 있는 다양한 방법들을 제공한다.
* 이를 사용해서 변경에 유연한 코드를 만들 수 있다.

변경 가능한 코드란 이해하기 쉬운 코드다. 

* 객체지향 패러다임은 우리가 세상을 바라보는 방식대로 코드를 작성할 수 있게 도와준다.
* 그래서 이해하기가 쉽다.

단순히 데이터와 프로세스를 객체(한곳)에 넣었다고해서 변경하기 쉬운 설계가 되는것은 아니다.

애플리케이션은 객체들로 구성되며, 하나의 애플리케이션은 객체들간의 상호작용을 통해 구현된다.
그리고 객체들 사이의 상호작용은 객체 사이에 주고받는 메시지로 표현된다.

* 애플리케이션의 기능을 구현하기 위해 객체들이 협력하는 과정 속에서 객체들은 다른 객체에 의존하게 된다. 
* 협력하는 객체 사이의 의존성을 적절하게 관리해야한다.
* 객체간의 의존성이 높을수록 코드를 변경하기 어렵기 때문이다.

```
훌륭한 객체지향 설계란 
협력하는 객체들 사이의 의존성을 적절하게 조절해서
변경에 용이한 설계를 만드는것이다.
```