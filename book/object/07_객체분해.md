# 7. 객체분해

### 인지과부하, 추상화, 분해

사람의 기억은 단기기억, 장기기억이 있다.

* 실제로 문제를 해결하기 위해서 사용하는 저장소는 **단기기억**이다.
* 문제를 해결하기 위해서는 필요한 정보들을 먼저 단기기억 안으로 불러와야한다.
* 그런데 이때 단기기억 용량을 초과하면 => 문제해결 능력은 급격하게 떨어진다. (인지 과부하)

인지 과부하를 방지하는 가장 좋은 방법은 

* **단기기억 안에 보관할 정보의 양을 조절**하는것이다. 
* 불필요한 정보를 제거하고 현재 문제해결에 필요한 핵심만 남겨야한다. (추상화)

가장 일반적인 추상화 방법은

* 한번에 다뤄야하는 문제의 크기를 줄이는거다. (분해)

한번에 단기기억에 담을 수 있는 추상화 수에는 한계가 있지만

* 추상화를 더 큰 규모의 추상화로 압축시키면 => 단기기억의 한계를 초월할 수 있다.

복잡성이 존재하는 곳에는 추상화가 존재한다.

* 소프트웨어 개발영역(=복잡한 문제를 해결하는곳) => 추상화, 분해 개념이 녹아있다.

## 7-1. 프로시저 추상화와 데이터 추상화

### 프로그래밍 언어, 프로그래밍 패러다임

프로그래밍 언어의 발전도 추상화를 통해 복잡성을 극복하려는 개발자들의 노력에서 출발했다.

* 어셈블리어: 숫자로 된 기계어가 너무 복잡하니까 => 사람이 이해할 수 있도록 노력한 예
* 고수준 언어: 기계적인 사고로 되어있는 명령어도 어려우니까 => 사람 눈높이에 맞춰보려고 노력한 예.

추상화는 "프로그래밍 패러다임"의 탄생으로 이어졌다.

* 프로그래밍 패러다임이란, 어떤 추상화 종류를 사용해서 소프트웨어를 분해할지 결정하는 원칙과 방법이다.

### 프로시저 추상화와 데이터 추상화

중요한 두가지 추상화 메커니즘이 있다.

1. 프로시저 추상화: 소프트웨어가 **무엇을 해야하는지** 추상화한다.
2. 데이터 추상화: 소프트웨어가 **무엇을 알아야하는지** 추상화한다.

앞에서 "프로그래밍 패러다임이란, 어떤 추상화 종류를 사용해서 소프트웨어를 분해할지 결정하는 원칙과 방법"이라고 했다. 


먼저 어떤 추상화 종류를 사용할지 정해야한다.

* 프로시저 추상화로 결정했다면:

	* 기능분해(functional decomposition), 알고리즘 분해(algorithmic decomposition)

* 데이터 추상화로 결정했다면:

	*  추상 데이터 타입(abstract data type): 데이터를 중심으로 타입을 추상화
	*  객체지향(object oriented): 데이터를 중심으로 프로시저를 추상화

객체지향 패러다임을 "역할과 책임을 수행하는 자율적인 객체들의 협력공동체를 구축하는것"이라고 설명했다.

* 역할과 책임을 수행하는 **객체**: 객체지향 패러다임이 이용하는 **추상화**
* 협력하는 공동체가 되도록 **객체들로 나누는 과정**: 객체지향 패러다임에서의 **분해**

### 정리하면

* 복잡성을 극복하는 방법은 **추상화 메커니즘을 정하고, 이를 기준으로 분해하는것**이다.
* 그러면 객체지향이 전통적인 기능분해 방법에 비해 효과적이라고 말하는 이유가 무엇일까?
	* 이 질문의 답을 찾기위해 전통적인 기능 분해방법에서 객체지향 분해방법에 이르는 역사를 살펴보자.

## 7-2. 프로시저 추상화와 기능 분해

### 메인함수로서의 시스템

기능 vs 데이터 => 처음에는 기능이 우세했다.

기능분해의 관점에서 추상화 단위는 프로시저이며, 시스템은 프로시저 단위로 분해된다.

* 프로시저: 반복적으로 실행되거나 유사하게 실행되는 작업들을 하나의 장소에 모아놓음으로써 => 로직을 재사용, 중복을 방지할 수 있는 추상화 방법이다.
* 프로시저를 추상화라고 부르는 이유: 상세구현 내용을 모르더라도 인터페이스만 알면 프로시저를 사용할 수 있기 때문이다.
* 상세 구현내용을 몰라도 된다는 말이, "정보은닉"처럼 보이지만 이 방법은 좀 한계가 있다. (뒤에서 자세히 이야기할것임.)

기능분해 관점에서 시스템은 **하나의 커다란 메인함수** 다.

* 기능분해 방법은 하향식 접근법(top-down)을 따른다.
* 가장 최상위 기능을 정의하고 => 좀 더 작은 단계의 하위 기능으로 분해해나간다. => 세분화된 마지막 하위 기능이 프로그래밍 언어로 구현가능한 수준이 될때까지 계속 분해한다.

```
example. 급여관리 시스템 설계 (p.220)
```

* 급여관리 시스템을 "입력받아 출력하는 커다란 하나의 메인함수"로 간주하고 기능분해를 시작했다.
	* 입력: 직원정보, 소득세율
	* 출력: 계산된 급여정보

기능분해 방법에서는 기능을 중심으로 필요한 데이터를 결정한다.

* 기능이 메인이고 데이터는 조연이다.
* 먼저 필요한 기능을 생각하고 => 이 기능을 분해하고 정제하는 과정에서 => 필요한 데이터의 종류와 저장방식을 정한다.
* 이런 방식은 유지보수에 다양한 문제를야기한다. (뒤에서 자세히 이야기할것임.)

```
example. 급여관리 시스템 구현 (p.222)
```

* 하향식 기능분해에서 커다란 기능을 작은 단위로 정제해가는 과정은 이상적인 방법으로 보이지만, 우리가 사는 세계와는 조금 다르다. 그래서 문제점이 있다. 이 부분에 대해 이야기해볼것이다.

### 하향식 기능분해의 문제점

하향식 기능분해를 실계 세계에 적용하다보면 이런 문제에 직면한다.

1. 시스템은 하나의 메인함수로 구성돼있지 않다.
2. 기능추가, 요구사항 변경 => 메인함수를 빈번하게 수정해야한다.
3. 비즈니스로직이 사용자 인터페이스와 강하게 결합된다.
4. 너무 이른시기에 함수들의 실행순서를 고정 => 유연성, 재사용성이 떨어진다.
5. 데이터 형식이 변결될 경우 파급효과를 예측할 수 없다.

"설계는 코드 배치 방법이며, 설계가 필요한 이유는 변경에 대비하기 위한 것"이라고 여러번 이야기했다.

* 소프트웨어에서 변경은 피할 수 없는 요소다.
* 현재 요구사항이 변하지 않고, 코드를 변경할 필요도 없다면 => 소프트웨어를 어떻게 설계하건 아무도 신경쓰지 않을것이다. 

하향식 접근법, 기능분해는 변경에 취약한 설계를 낳는다. 

* 왜 그런지 자세히 이야기해보겠다.

#### 1. 하나의 메인함수라는 비현실적인 아이디어

어떤 시스템도 최초 릴리즈 됐던 모습을 그대로 유지하지 않는다. 지속적으로 새로운 기능을 추가하게 된다.

* 이것은 시스템이 하나의 메인함수로 구현된다는 개념과 모순이다.
* 이 구조에서 기능을 추가하다보면 결국 처음에는 중요하게 생각했던 메인함수는 동등하게 중요한 여러 함수들 중 하나가 되어버린다.
* 이러면 "시스템은 하나의 큰 메인함수"라는 개념은 사라지고, "여러개의 동등한 수준의 함수집합"으로 성장하게된다.

대부분의 시스템에서 하나의 메인기능이란 개념은 존재하지 않는다.

* 현대적인 시스템은 동등한 수준의 다양한 기능으로 구성된다. 
* 각 기능들은 동등하게 독립적이고 완결된 하나의 기능을 표현한다.

하향식 접근법은 하나의 알고리즘이나 배치를 구현하기에는 적합하지만, 현대적인 상호작용 시스템 개발에는 적합하지 않다.

#### 2. 메인함수의 빈번한 재설계

하향식 기능분해의 경우에는 새로운 기능을 추가할때마다 매번 메인함수를 수정해야한다.

* 기존 로직과는 아무 상관이 없는 새로운 함수의 적절한 위치를 확보해야하기 때문에, 메인함수 구조를 바꿀 수밖에 없는 것이다.
* 기존코드를 수정하는것은 항상 새로운 버그 발생 가능성을 높인다. 추가된 코드와 아무 상관도 없는 위치에서 변경이 일어난다면, 문제다.

```
example. 하향식 기능분해로 설계한 급여관리 시스템에 새로운 요구사항이 생겼다. (p.227)
```

* 이 예제는 하나의 메인함수에서 출발하는 하향식 접근법에 어떤 문제가 있는지 잘 보여준다.
* 시스템은 여러개의 정상(top)으로 구성되기 때문에, sumOfBasePays함수같은 새로운 정상을 추가할때마다 하나의 정상이라고 간주했던 main함수의 내부구현을 수정할 수밖에 없다.
* 이는 기존코드의 빈번한 수정 => 버그발생확률 증가 => 결과적으로 변경에 취약한 시스템이 된다.

> 정상(top): 독립적인 하나의 완성된 기능.

#### 3. 비즈니스로직, 사용자 인터페이스의 결합

하향식 접근법은 설계 초기단게부터 입력방법, 출력양식을 함께 고민하도록 강요한다.

* "사용자로부터 소득세율을 입력받아 급여를 계산한 후 계산된 결과를 화면에 출력한다."
	* 급여를 계산 => 비즈니스 로직
	* 계산된 결과를 화면에 출력 => 사용자 인터페이스 
	* 비즈니스 로직, 사용자 인터페이스 두 관심사가 한데 섞여있다. 
* 결과적으로 코드 안에서 비즈니스로직, 사용자 인터페이스가 밀접하게 결합된다.

문제는 비즈니스 로직, 사용자 인터페이스의 변경빈도가 다르다는 것이다.

* 사용자 인터페이스는 시스템에서 자주 변경되는 부분이다.
* 비즈니스로직, 사용자인터페이스가 한곳에 섞여있기 때문에 => 사용자 인터페이스를 변경하는 경우 비즈니스로직까지 변경에 영향을 받는다.
* 결과적으로 변경에 취약한 시스템이 된다.

#### 4. 성급하게 결정된 실행순서

하향식 기능분해는 "하나의 함수를 더 작은 함수로 분해하고, 분해된 함수들의 실행순서를 결정하는 작업"으로 요약할 수 있다.

* 메인함수가 작은 함수들로 분해되기 위해서는 우선 함수들의 순서를 결정해야한다. 
* 필요한 함수들의 실행순서를 미리 결정하지 않는 한 기능분해를 진행할 수 없다.

실행순서, 조건, 반복같은 제어구조를 미리 결정해야 분해를 할 수 있기 때문에 "중앙집중 제어스타일"형태를 띨 수 밖에 없다.

* 결과적으로 모든 **중요한 제어흐름의 결정이 상위함수에서 이뤄지고, 하위함수는 상위함수의 흐름에 따라 적절한 시점에 호출된다.**

문제는 중요한 흐름인 함수의 제어구조가 빈번한 변경대상이라는 점이다.

* 기능이 추가되거나 변경될때마다 초기에 결정된 함수들의 제어구조를 변경해야한다.
* 이를 해결할 수 있는 한가지 방법은 자주 변경되는 "시간적인 제약"을 버리고, 비교적 안정적인 "논리적 제약"을 설계 기준으로 삼는 것이다.
	* 객체지향은 함수간의 호출순서가 아니라, 객체간의 논리적인 "관계"를 중심으로 설계를 이끌어나간다.
	* 결과적으로 어떤 한 구성요소로 제어가 집중되지 않고, 여러 객체들한테 제어 주체가 분산된다.

하향식 접근법을 통해 분해한 함수들은 재사용하기도 어렵다.

* 상위함수가 강요하는 문맥 안에서만 의미를 갖기 때문이다.
* 하향식 접근법으로 설계한 하위함수는 일반적이지 않다. => 재사용이 어렵다.

하향식 설계와 관련된 모든 문제의 원인은 **결합도**다.

* 함수는 상위함수가 강요하는 문맥에 강하게 결합되고, 함께 절차를 구성하는 다른 함수들과 시간적으로 강하게 결합되어있다.
* 강한 결합도는 시스템을 변경에 취약하게 만들고, 이해하기 어렵게 만든다.
* 현재 문맥에 강하게 결합되어있기 때문에 다른 문맥에 재사용하기도 어렵다.

#### 5. 데이터 변경으로 인한 파급효과

하향식 기능분해의 가장 큰 문제점은 "어떤 데이터를 어떤 함수가 사용하고있는지 추적하기 어렵다"는 것이다.

* 물론 개별함수 안에서 사용하는 데이터를 파악하는 것은 어렵지 않다.
* 그러나 반대로 **어떤 데이터가 어떤 함수에 의존성이 있는지** 파악하는것은 어렵다.

```
example. 하향식 기능분해로 설계한 급여관리 시스템의 데이터를 변경해보자. (p.231)
```

* 데이터 변경으로 인해 발생하는 함수에 대한 영향도를 파악하는것은 쉽지 않다.
	* 누가 전역변수 추가했다고 기존의 sumOfBasePays함수가 수정될 것이라고 예상할 수 있었을까!

데이터 변경으로 인한 영향을 최소화하려면 데이터와 함께 변경되는 부분과 그렇지 않은 부분을 명확하게 분리해야한다.

* 데이터와 함께 변경되는 부분을 => 하나의 구현단위로 묶고
* 외부에서는 잘 정의된 퍼블릭 인터페이스를 통해서만 데이터에 접근하도록 통제해야한다.

### 그럼 언제 하향식 분해가 유용할까

설계가 어느정도 안정화 된 후, 문서화하기에는 유용하다.

* 단, 문서화하는데 적절한 방법과 좋은 구조를 설계하는 방법은 다르다.

작은 프로그램과 개별알고리즘을 위해서는 유용한 패러다임이다.

## 7-3. 모듈

### 시스템의 변경을 관리하는 기본적인 전략

* 함께 변경되는 부분을 하나의 구현단위로 묶고
* 퍼블릭 인터페이스를 통해서만 접근하도록 만드는 것이다.

즉, 기능을 기반으로 시스템을 분해하는것이 아니라 **변경의 방향에 맞춰 시스템을 분해**하는것이다.

### 정보은닉과 모듈

* 정보은닉: 시스템에서 자주 변경되는 부분을 "안정적인 인터페이스 뒤로 감춰야한다"는 것이 핵심이다.
	
	* 정보은닉은 외부에 감춰야하는 비밀에 따라 시스템을 분할하는 모듈분할 원리다.

* 모듈: 변경될 가능성이 있는 비밀을 내부로 감추고, 잘 정의되고 안정적인 퍼블릭 인터페이스를 외부에 제공해서 => 내부 비밀에 함부로 접근하지 못하게 통제한다.

**모듈과 기능분해는 상호배타적인 관계가 아니다.**

* 감춰야하는 비밀을 선택하고 모듈을 분해한 후 모듈 내부를 구현할때는 기능분해를 이용해 모듈에 필요한 퍼블릭 인터페이스를 구현할 수 있다.

시스템을 모듈단위로 어떻게 분해할것인가?

1. 우선 시스템이 감춰야하는 비밀을 찾고
2. 외부에서 이 비밀에 직접 접근하지 못하도록 퍼블릭 인터페이스로 방어한다.

모듈은 어떤 비밀을 감춰야하나?

* 복잡성
* 변경가능성

```
example. 급여관리 시스템에서 비밀을 정하고 감춰보자. (p.236)
```

### 모듈의 장점

1. 모듈 내부 변수가 변경되더라도 모듈 내부에만 영향을 미친다.

2. 비즈니스 로직과 사용자 인터페이스에 대한 관심사를 분리한다.

	* 사용자 입력과 화면출력은 Employees 모듈 내부로 가져오지 않고 그대로 외부에 뒀다.

3. 전역변수와 전역함수를 제거 => 네임스페이스오염을 방지한다.

	* 모듈의 한가지 용도는 네임스페이스를 제공하는것이다.
	* 이제 다른 모듈에서도 동일한 이름을 사용할 수 있게 된다.

모듈은 변경의 정도에 따라 시스템을 분해하게한다.

* 각 모듈은 감춰야하는 비밀 데이터와 함수의 집합이다. => 높은 응집도
* 모듈간에는 퍼블릭 인터페이스를 통해서만 통신한다. => 낮은 결합도

여기서 중요한점은 모듈이 정보은닉이라는 개념을 통해 => 데이터라는 존재를 설계의 중심요소로 부각시켰다는 점이다.

* 모듈에서 핵심은 데이터다.
* 모듈은 감춰야할 데이터를 결정하고 이 데이터를 조작하는데 필요한 함수를 결정한다.
* 다시말해 기능이 아니라 데이터를 중심으로 시스템을 분해한다.

### 모듈의 한계

모듈이 프로시저 추상화보다는 높은 추상화 개념을 제공하지만, 한계점이 명확하다.

인스턴스를 제공하지 않는다는 점이다.

* Employees 모듈은 단지 회사에 속한 모든 직원 정보를 갖고있을 뿐이다.
* 좀더 높은 수준의 추상화를 위해서는 개별 직원을 독립적인 단위로 다룰 수 있어야한다. (인스턴스)
* 다수의 직원 인스턴스가 존재하는 추상화 메커니즘이 필요한것이다.

이를 만족시키기 위해 등장한 개념이 추상 데이터타입이다.

## 7-4. 데이터 추상화와 추상 데이터 타입

### 추상 데이터 타입

프로그래밍 언어에서 타입이란,

1. 변수에 저장할 수 있는 내용물의 종류
2. 변수에 적용될 수 있는 연산의 가짓수를 의미한다.

프로그래밍 언어는 다양한 형태의 내장타입(built-in type)을 제공한다.

* 기능분해 시대에 사용되던 절차형 언어들은 내장타입이 적었고, 새로운 타입을 추가하는것도 불가능하거나 제한적이었다.
* 이 시대의 프로그래밍에서 사용하던 주된 추상화는 프로시저 추상화였는데, 시간이 흐르면서 사람들은 프로시저 추상화는 프로그램 표현력을 향상시키는데 한계가 있음을 인지했고, 바바라리스코프는 **데이터 추상화**개념을 제안했다.


```
example. 바바라 리스코프 말씀 (p.241)
* 추상 데이터타입은 추상 객체의 클래슬르 정의한것으로, 추상 객체에 사용할 수 있는 오퍼레이션을 이용해 규정된다.
* 이것은 오프레이션을 이용해 추상데이터 타입을 정의할 수 있음을 의미한다.
* 추상 데이터 객체를 사용할 때 프로그래머는 오직 객체가 외부에 제공하는 행위에만 관심을 가지며, 행위가 구현되는 세부적인 사항에 대해서는 무시한다.
* 구현정보는 내부 오퍼레이션을 구현할때만 필요하다. 객체의 사용자는 이 정보를 알 필요가 없다.
```

* 인용문에 지금까지 설명했던 데이터 추상화, 정보은닉, 데이터 캡슐화, 인터페이스-구현 분리의 개념들이 모드 다 녹아있다.
* 추상데이터타입은 데이터 추상화를 기반으로 소프트웨어를 개발한 최초의 발걸음이다.

추상데이터타입을 구현하려면 다음과같은 프로그래밍 언어의 지원이 필요하다.

* 타입정의를 선언할 수 있어야한다.
* 타입의 인스턴스를 다루기 위해 사용할 수 있는 오퍼레이션 집합을 정의할 수 있어야한다.
* 제공된 오퍼레이션을 통해서만 제어할 수 있도록 데이터를 외부로부터 보호할 수 있어야한다.
* 타입에 대해 여러개의 인스턴스를 생성할 수 있어야한다.

```
example. 추상 데이터타입을 통해 급여관리 시스템을 개선해보자. (p.242)
``` 

추상 데이터타입은 사람들이 세상을 바라보는 방식에 좀 더 근접하게 추상화 수준을 향상시킨다.

* 추상 데이터타입 정의를 기반으로 객체를 생성하는 것은 가능하지만, 여전히 데이터와 기능을 분리해서 바라보고있다.
* 추상 데이터타입은 시스템의 상태를 저장할 데이터를 표현한다.
* 추상 데이터타입으로 표현된 데이터를 이용해서 기능을 구현하는 핵심 로직은 추상데이터타입 외부에 존재한다.

```
example. 급여관리시스템의 경우 main함수 로직들이 이 데이터를 사용하는 코드다. 
```

추상 데이터타입은 데이터에 관한 관점을 설계의 표면으로 끌어올리기는 하지만, **여전히 데이터와 기능을 분리해서 바라보고있다.**

프로그래밍 언어 관점에서 추상 데이터 타입은 프로그래밍 언어의 내장 데이터 타입과 동일하다.

* 단지 타입을 개발자가 정의할 수 있다는 점이 다를 뿐이다.

추상 데이터타입에 대한 이런 관점은 종종 객체지향 프로그래머들을 혼돈으로 몰아간다.

그럼 클래스는 추상 데이터타입인가?

> 이해가 잘 안됨 ㅠㅠ

## 7-5. 클래스
 
### 클래스는 추상 데이터타입인가?

클래스와 추상데이터타입 모두 추상화를 기반으로 시스템을 분해하기 때문에 이 설명이 꼭 틀린 것만은 아니다.

* 두 메커니즘 모두 외부에서는 객체 내부 속성에 직접 접근할 수 없으며,
* 오직 퍼블릭 인터페이스를 통해서만 외부와 의사소통할 수 있다.

그러나 명확한 의미에서 추상 데이터 타입과 클래스는 다르다.

* 가장 핵심적인 차이는 클래스는 상속과 다형성을 지원하지만, 추상 데이터타입은 지원하지 못한다는 점이다.
	
	* 상속과 다형성을 지원 => 객체 지향 프로그래밍 (Object-OrientedProgramming)
	* 추상 데이터타입 기반 => 객체 기반 프로그래밍 (Object-Based Programming)

* 언어적인 관점(by 윌리엄 쿡)

	* 클래스는 절차를 추상화한것 (Procedual abstraction)
	* 추상 데이터타입은 타입을 추상화한것 (Type abstraction)

```
example. 추상 데이터타입으로 구현된 Employee 타입을 살펴보자. (p.245)
```

* Employee 타입은 **물리적으로는** 하나의 타입이지만, **개념적으로는** 정규직원과 아르바이트 직원 두개의 개념을 포함하고있다.
* Employee 타입이 제공하는 퍼블릭 오퍼레이션 `calculatePay()`, `monthlyBasePay()`는 직원 유형에 따라 서로 다른 방식으로 동작한다.
* 설계관점에서 Employee 타입은 구체적인 직원 타입을 외부에 캡슐화하고있다.


#### 타입 추상화, 추상 데이터타입, 클래스

하나의 대표적인 타입이 다수의 세부적인 타입을 감추고있다. => 타입 추상화

* 타입추상화는 오퍼레이션을 기준으로 타입을 통합한다.
* 타입 추상화를 기반으로 하는 대표적인 기법이 => 추상 데이터타입

```
example. 추상 데이터타입 Employee
* Employee를 사용하는 클라이언트는 calculate(), monthlyBasePay() 오퍼레이션을 호출할 수 있지만 정규직원 타입, 아르바이트직원 타입이 있다는 사실은 알 수 없다.
* 두개의 직원 타입은 Employee 내부에 감춰져있다.
```

추상 데이터타입이 오퍼레이션을 기준으로 타입을 묶는 방법이라면, 객체지향은 타입을 기준으로 오퍼레이션을 묶는다.

* 정규직원, 아르바이트직원 두개의 타입을 명시적으로 정의하고 각 타입에 대한 오퍼레이션을 두 타입에 분배한
다.

```
example. 객체지향 관점에서 Employee
* 정규직원, 아르바이트직원 각각 클래스를 정의하고 각 클래스들이 calculatePay(), monthlyBasePay()를 구현하게 될 것이다.
```

두가지 클래스로 분리할 경우 공통로직을 어디에 둘것인지가 이슈가 된다.

* 가장 간단한 방법은 공통로직을 포함할 상위클래스를 정의하고, 두 직원 타입 클래스가 상위클래스를 상속받게 하는것이다.
* 이제 클라이언트가 상위클래스의 참조자에 대해 메시지를 전송하면 => 실제 클래스가 무엇인가에 따라 적절한 절차가 실행된다.
* 이것이 바로 다형성이다.

클라이언트 관점에서 두 클래스의 인스턴스는 동일하게 보인다. 

* 실제로 내부에서 수행되는 절차는 다르지만 **클래스를 이용한 다형성은 절차에 대한 차이점을 감춘다.**
* 객체지향은 절차 추상화(procedural abstraction)다.

#### 결론

```
클래스는 추상 데이터타입인가? 아니다. 조금 다르다.
```

* 추상 데이터타입은 오퍼레이션을 기준으로 타입들을 추상화한다.
* 클래스를 이용하는 객체지향은 타입을 기준으로 절차들을 추상화한다.

### 추상 데이터타입에서 클래스로 변경하기

급여관리시스템을 클래스로 변경해보자.

* 추상 데이터타입을 사용한 구현예에서는 Employee 하나의 타입 안에 두가지 직원 타입을 캡슐화했다.
* 클래스를 이용하는 객체지향 버전에서는 각 직원 타입을 독립적인 클래스로 구현한다.

```
example. 급여관리시스템을 클래스로 변경하는 예제(p.247)
```

### 변경을 기준으로 선택하라

#### 추상 데이터타입과 객체지향: 코드 모양

단순히 클래스를 구현단위로 사용하는것이 객체지향 프로그래밍은 아니다.

* 타입을 기준으로 절차를 추상화하지 않았다면 그것은 객체지향 분해가 아니다.

클래스가 추상 데이터타입의 개념으 따르고있는지 확인하는 가장 간단한 방법은 "클래스 내부에 인스턴스의 타입을 표현하는 변수가 있는지 살펴보는것"이다.

```
example. Employee 에서는 hourly 변수로 정규직원, 아르바이트직원을 구분했다.
```

* 변수에 저장된 값을 기반으로 메서드에서 타입을 구분하고있다면 => 객체지향을 위반한것이다.

객체지향에서는 타입 변수를 판단하는 조건문을 => 다형성으로 대체한다.

* 클라이언트가 객체의 타입을 확인한 후 적절한 메서드를 호출하는것이 아니라, 객체가 메시지를 처리할 적절한 메서드를 선택한다.

#### 추상 데이터타입과 객체지향: 변경

추상 데이터타입을 사용한 구현은 변경에 취약하다.

```
example. 추상데이터 타입을 기반으로 한 Employee에 새로운 직원 타입이 추가된다면?
* hourly 값을 체크하는 클아이언트의 조건문을 모두 찾아 수정해야한다. 
```

객체지향은 변경에 강하다.

```
example. 객체지향을 기반으로 한 Employee에 새로운 직원 타입이 추가된다면?
* 새로운 직원 유형 클래스를 Employee 상속 계층에 추가하고 필요한 메서드를 오버라이딩하면 된다.
```

* 시스템에 새로운 로직을 추가하기 위해 클라이언트 코드를 수정할 필요가 없다.

#### 개방폐쇄 원칙(Open-Closed Principle)

* 기존 코드에 아무 영향도 미치지 않고 새로운 객체 타입과 행위를 추가할 수 있는 객체지향의 특성을 "개방폐쇄원칙"이라 한다.
* 이것이 객체지향설계가 전통적인 방법에 비해 변경, 확장이 쉬운 구조를 설계할 수 있는 이유다.

#### 그러면 추상 데이터타입은 항상 잘못된 방식인걸까?

```
아니다. 설계는 변경과 관련된것이다. 
어떤 설계가 더 유용한지는 변경의 방향성과 발생빈도에 따라 결정된다. 
변경의 축을 찾아라.
```

* 새로운 타입을 빈번하게 추가해야한다면 => 객체지향 클래스 구조가 더 유용하다.
* 새로운 오퍼레이션을 빈번하게 추가해야한다면 => 추상 데이터타입을 사용하는 구조가 더 유용하다.

### 협력이 중요하다.

객체지향에서 중요한것은 **역할, 책임, 협력**이다.

* 객체지향은 기능을 수행하기 위해 객체들이 협력하는 방식에 집중한다.
* 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션의 구현방식을 타입별로 분배하는것은 올바른 접근법이 아니다.

객체지향을 설계하는 방법

1. 객체가 참여할 협력을 결정하고
2. 협력에 필요한 책임을 수행하기 위해 어떤 객체가 필요한지에 관해 고민하라.
3. 그 책임을 다양한 방식으로 수행해야할 때만 타입계층 안에 각 절차를 추상화하라.
	* 타입계층과 다형성은 협력이라는 문맥 안에서 책임을 수행하는 방법에 관해 고민한 결과물이어야한다.
	* 타입계층과 다형성 자체가 목적이 되어서는 안된다.
